//
//  ViewController.m
//  RSA加密方法
//
//  Created by 赵鹏 on 2018/12/6.
//  Copyright © 2018 赵鹏. All rights reserved.
//

/**
 参考网站：http://songshuhui.net/archives/84941
         http://songshuhui.net/archives/84947
 
 信息加密的历史：
 在1976年以前，所有的信息都使用同一种模式进行加密，甲方选择某一种加密规则，对信息进行加密，然后乙方使用同一种规则，对信息进行解密。这种加密规则叫做“密钥”，这种加密模式叫做“对称加密算法(Symmetric-key algorithm)”。这种对称加密算法的加密模式最大的弱点是甲方必须把加密规则告诉乙方，而在实际操作过程中客户端把加密规则传递给服务器端的时候，这个加密规则有可能会被第三方窃取到，从而破解将来被传递的加密信息，得到加密之前的明文信息。除了上述的危险之外，把加密规则告诉服务器端的话，服务器端在得到加密之后的暗文信息以后可以逆推得到加密之前的明文信息。所以说这种对称加密算法的加密模式不安全。
 1976年，两位美国计算机学家迪菲(W.Diffie)、赫尔曼(M.Hellman)提出了一种崭新的构思，可以在不直接传递密钥的情况下，完成解密，这种加密模式被称为“迪菲赫尔曼密钥交换算法”，也叫做“非对称加密算法”。这种加密模式启发了其他科学家，人们认识到加密和解密可以使用不同的规则（密钥），只要这两种规则之间存在某种对应的关系即可，这样就避免了客户端和服务器端直接传递密钥而可能引发的不安全性。
 例子：服务器端生成两把密钥（公钥和私钥），公钥是公开的，任何人都可以得到，私钥则是保密的，只有服务器自己知道。客户端提前得到服务器的公钥，当客户端想要向服务器端发送信息的时候，客户端利用服务器端的公钥对明文信息进行加密，从而变成了暗文信息，然后把暗文信息传递给服务器，服务器在得到暗文信息以后利用它自己的私钥对这些暗文信息进行解密，从而得到了最开始的明文信息。这个暗文信息只能由当初给他加密的服务器端的公钥所对应的私钥来进行解密，除此之外则不能解密。在暗文信息传递的过程中如果被第三方截取到的话，因为第三方没有对应的私钥，所以不能把暗文信息进行解密，从而保证了传输的安全性。综上所述，经过公钥加密的信息只有对应的私钥才能解的开，那么只要私钥不泄露，通信就是安全的。
 1977年三位麻省理工学院的数学家：罗纳德·李维斯特(Ron Rivest)、阿迪·萨莫尔(Adi Shamir)和伦纳德·阿德曼(Leonard Adleman)一起设计了一种可以实现非对称加密的算法，这种算法用他们三个人的名字命名，叫做RSA算法。从那时起直到现在，RSA算法一直是最广为使用的"非对称加密算法"，毫不夸张地说，只要有计算机网络的地方，就有RSA算法。
 这种RSA算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法被破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。
 
 RSA算法的原理：
 需要用到如下的几个数学知识：
 1、互质关系：如果两个正整数，除了1以外，没有其他公因数，我们就称这两个数是互质关系(coprime)；
 2、欧拉函数：任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）计算这个值的方法就叫做欧拉函数，以φ(n)表示；
 3、欧拉定理：上述欧拉函数的用处在于欧拉定理。"欧拉定理"指的是：如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除；
 4、费马小定理：欧拉定理的特殊情况：如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1；
 5、模反元素：如果两个正整数e和x互质，那么一定可以找到整数d，使得 ed-1 被x整除，那么d就是e对于x的“模反元素”。
 
 密钥生成的步骤：
 通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？
 第一步，随机选择两个不相等的质数p和q，爱丽丝选择了61和53（实际应用中，这两个质数越大，就越难破解）；
 第二步，计算p和q的乘积n。爱丽丝就把61和53相乘，n = 61×53 = 3233。n的长度就是密钥长度，3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位；
 第三步，计算n的欧拉函数φ(n)。根据公式：φ(n) = (p-1)(q-1)，爱丽丝算出φ(3233)等于60×52，即3120；
 第四步，随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n)互质。爱丽丝就在1到3120之间，随机选择了17（实际应用中，常常选择65537）；
 第五步，计算e对于φ(n)的模反元素d。所谓"模反元素"就是指有一个整数d，可以使得ed被φ(n)除的余数为1，ed ≡ 1 (mod φ(n))。经过"扩展欧几里得算法"求得d=2753。
 至此所有计算完成。
 第六步，将n和e封装成公钥，n和d封装成私钥。在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。实际应用中，公钥和私钥的数据都采用ASN.1格式表达。
 
 RSA算法的可靠性：
 回顾上面的密钥生成步骤，一共出现六个数字：p、q、n、φ(n)、e、d，这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。那么，有无可能在已知n和e的情况下，推导出d？（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。（3）n=pq。只有将n因数分解，才能算出p和q。结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道："对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"因此目前被破解的最长RSA密钥就是768位。
 
 加密和解密：有了公钥和密钥，就能进行加密和解密了。
 1、加密要用公钥 (n,e)：
 假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。所谓"加密"，就是算出下式的c：me ≡ c (mod n)。爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：6517 ≡ 2790 (mod 3233)，于是c等于2790，鲍勃就把2790发给了爱丽丝；
 2、解密要用私钥(n,d)：
 爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：cd ≡ m (mod n)也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出27902753 ≡ 65 (mod 3233)
 因此，爱丽丝知道了鲍勃加密前的原文就是65。
 至此，”加密--解密“的整个过程全部完成。可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。
 
 公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。
 
 因为RSA的运算效率比较低，所以它一般对比较小的数据进行加密。对于大数据的话一般用对称加密模式进行加密，在加密之前服务器端需要把加密规则（密钥）传递给客户端，因为这个密钥不大，所以事先需要用RSA对这个密钥进行加密，然后再传递给客户端，这样才比较安全。
 
 在Mac电脑的终端中生成公钥(.pem)和私钥(.pem)，但是在代码里面加密的时候一般不用这些.pem文件。然后利用刚刚生成的私钥再生成一个申请证书文件(.csr)，在生成该文件的过程中要填写必要的个人信息。然后利用刚刚生成的.csr文件向上述提到的那三个研究出RSA加密算法的数学家成立的证书颁发机构来申请证书（需要交费，一年五千人民币），就会得到他们颁发的.crt证书，这个证书也不会直接用，还需要做进一步的转换。然后利用颁发的.crt证书再生成一个.der文件，这个文件中包含公钥以及其他的一些信息。然后再利用.crt证书生成一个.p12文件，这个.p12文件就是私钥了。在代码中利用上述生成的公钥（.der文件）和私钥（.p12文件）来对数据进行加密和解密。在实际的开发过程中，上述的.der和.p12文件不一定都获得到，在这里都获得到的目的是为了这个Demo演示使用，在这个Demo中既对数据进行加密又对数据进行解密。
 */
#import "ViewController.h"
#import "RSACryptor.h"

@interface ViewController ()

@end

@implementation ViewController

#pragma mark ————— 生命周期 —————
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    //1、加载公钥
    [[RSACryptor sharedRSACryptor] loadPublicKey:[[NSBundle mainBundle] pathForResource:@"rsacert.der" ofType:nil]] ;
    
    //2、加载私钥（模拟服务器的做法）
    [[RSACryptor sharedRSACryptor] loadPrivateKey:[[NSBundle mainBundle] pathForResource:@"p.p12" ofType:nil] password:@"123456"];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    /**
     把需要传递给服务器的"hello"字符串先转换成NSData二进制数据的形式，然后再调用加密方法"encryptData:"给二进制数据加密；
     每次加密后的结果相同或者不同取决于加密时候选的填充模式"kTypeOfWrapPadding"，在本Demo中选的是"kSecPaddingPKCS1"所以才会导致每次加密后的结果不一样，如果选择"kSecPaddingNone"的话则每次加密后的结果是相同的。
     */
    NSData * ret = [[RSACryptor sharedRSACryptor] encryptData:[@"hello" dataUsingEncoding:NSUTF8StringEncoding]];
    
    //把加密后的二进制数据进行Base64编码，然后再进行传输。
    NSString * base64 = [ret base64EncodedStringWithOptions:0];
    NSLog(@"数据加密后并且经过Base64编码后的结果：%@",base64);
    
    //解密
    NSData * jiemi = [[RSACryptor sharedRSACryptor] decryptData:ret];
    NSLog(@"数据解密后并且转化成字符串后的结果：%@",[[NSString alloc] initWithData:jiemi encoding:NSUTF8StringEncoding]);
}

@end
